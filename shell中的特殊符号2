；分号

连续运行命令

    # ifdown eth0;ifup eth0

| 管道

正则表达式中表示或者

    # echo "ooooee" |egrep '(oo|ee)'{2}   表示匹配 oooo 或者 eeee 的字符

前面命令的标准输出作为后面命令的标准输入

    # ifconfig|grep eth0     表示ifconfig查出来的信息然后过滤出eth0的这一行

&

将命令放到后台执行

    # mysqld_safe --user=mysql &        将MySQL放到后台启动

表示标准输出和标准错误输出

    # ifconfig &>/dev/null   将ifconfig执行得到的结果输出到/dev/null里面

&&

前面命令返回值为0才执行后面的命令

    # ls && echo "ok"  

||

前面命令返回值为非0才执行后面的命令

    # lls || echo "ok" 

# 井号

# 表示注释

$# 表示位置参数的个数

    # echo $#
    0

${#变量名} 表示变量的长度

    # a='hello'
    # echo ${#a}
    5

${#变量名[@]} 表示数组的个数

    # a=(1 2 3)
    # echo ${#a[@]}
    3

！惊叹号

将命令或者条件表达式的返回值取反

    # if ! [ 1<2 ]; then echo 'ok'; else echo 'no'; fi
    ok

执行历史命令

    # history 
    1  ls
    2  tail test1.txt
    3  mysql -uroot -p123
    4  ls /tmp/
    5  cd /tmp/
    [root@localhost ~]# !994
    ls /tmp/
    account.sql  data.sql  mysql.sock  t1.txt  t2.txt 

vi或者ftp中执行外部shell命令

例如：在vim中，想要执行一条命令，就在末行模式，输入！感叹号后面加上要执行的命令

间接应用变量

例如：${!a} ---- 间接取b 的值

$ 美元符号

取变量的值

    # a=10
    # echo $a
    10

正则表达式表示行尾

    egrep ':$' /etc/inittab 
    egrep ‘^hello$'  file

> 大于号

输出重定向

    echo '123' >test.txt       表示将123 输入到文件test.txt中

条件测试中的大于号

< 小于号

输入重定向

条件测试中的小于号

= 等号

变量赋值 - 例如：设置变量a=10

条件测试中的等号 - 例如：[ a=b ] 判断变量a是否等于b

数值比较 == - 例如：(( a==20 )) 判断变量a是否等于20

+ 加号

算术运算中的加号 - 例如：1+3

正则表达式中1个或多个前面的字符 - 例如：ab+c 表示匹配ab和c之间有1个或者多个 字符

>>

输出重定向追加 - 例如：echo "123" >> test.txt 将123追加到文件test.txt中

<<

here document

例如：

    # passwd <<end
    > 123
    > 123
    > end

更改用户 root 的密码 。

- 减号

算术运算中的减号 - 例如：10-2

命令的选项 - 例如：ls -l

上一次工作目录 - 例如：cd -

通配符和正则表达式中表示范围 - 例如：[a-z]

    tar -cvf - /home | tar -xvf - 

表示输出流或输入流

将前面的输出 ，通过管道交给后面的命令，前面的压缩，后面的解压

'' 单引号

解决变量赋值空格的问题

例如：a='1 2'

阻止shell替换

"" 双引号

解决变量赋值空格的问题

例如：a="1 2"

阻止shell部分字符替换，对$、！等无效

`` 反引号 相当于 $()

命令行替换

例如：可以设变量

    a=`ls`

注意：使用反引号时，需要将转义符再次进行转义！！ 

% 百分号

算术运算中的模运算

例如：echo $((100%10)) 就是100除以10的余数为0

vi中替换操作中表示所有行 （末行模式下，替换所有前面加 %）

例如：在末行模式下输入 :% s/D/d 表示将文本中的所有的D替换为d

() 单圆括号

子shell中执行命令，会继承父shell的变量

括起数组元素

例如：定义一个数组 a=(1 2 3 4)

(()) 双圆括号

算术运算

例如：echo $((10/2)) 结果就是5

整数比较测试

例如：(( 10>2 )) 判断10是否大于2

[] 单方括号

通配符和正则中表示匹配括号中的任意一个字符

例如：[abc] 表示匹配abc中的任意一个字符

条件测试表达式

例如： [ -f /etc/passwd ] // 测试是不是文件

数组中下标括号

例如：echo ${a[0]} 表示取数组中下标为0的值

[[]] 双方括号

字符串比较测试

例如：[[a=b]] 用来字符串的比较

. 英文句点号

正则中表示任意1个字符

例如：a...b 表示 匹配 a和b之间夹三个字符的字符串

当前shell执行脚本命令

例如：./test.sh 执行当前路径下的shell脚本test.sh

表示当前目录

例如：cd ./bgk 进入当前目录下的bgk目录下

{} 大括号

通配符扩展 abc{1,2,3}

正则表达式中表示范围

例如：a{3} 匹配3个 a

for i in {1...10} 循环指定范围

匿名函数{ cmd1；cmd2；cmd3；} &> /dev/null

{ } 里面的命令，是在当前shell执行

注意：{ } 第一条命令前面要有空格，后面的命令要有分号

括起变量名 ${abc}a

/ 正斜杠

算术运算中的除法

例如：echo $((10/2)) 结果就是5

根目录或路径分割符

例如：cd /usr/local/ 表示路径

^

在通配符中表示取反

例如：abc 表示匹配除了abc外的任意一个字符

在正则表达式中表示以什么开头

例如：

    egrep ‘^hello$'  file

1、单小括号 ()

   ①命令组。括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被脚本余下的部分使用。括号中多个命令之间用分号隔开，最后一个命令可以没有分号，各命令和括号之间不必有空格。

   ②命令替换。等同于cmd，shell扫描一遍命令行，发现了$(cmd)结构，便将$(cmd)中的cmd执行一次，得到其标准输出，再将此输出放到原来命令。有些shell不支持，如tcsh。

    ③用于初始化数组。如：array=(a b c d)

 

 

2、双小括号 (( ))

    ①整数扩展。这种扩展计算是整数型的计算，不支持浮点型。((exp))结构扩展并计算一个算术表达式的值，如果表达式的结果为0，那么返回的退出状态码为1，或者 是"假"，而一个非零值的表达式所返回的退出状态码将为0，或者是"true"。若是逻辑判断，表达式exp为真则为1,假则为0。

    ②只要括号中的运算符、表达式符合C语言运算规则，都可用在$((exp))中，甚至是三目运算符。作不同进位(如二进制、八进制、十六进制)运算时，输出结果全都自动转化成了十进制。如：echo $((16#5f)) 结果为95 (16进位转十进制)

    ③单纯用 (( )) 也可重定义变量值，比如 a=5; ((a++)) 可将 $a 重定义为6

    ④常用于算术运算比较，双括号中的变量可以不使用$符号前缀。括号内支持多个表达式用逗号分开。 只要括号中的表达式符合C语言运算规则,比如可以直接使用for((i=0;i<5;i++)), 如果不使用双括号, 则为for i in seq 0 4或者for i in {0..4}。再如可以直接使用if (($i<5)), 如果不使用双括号, 则为if [ $i -lt 5 ]。

二、中括号，方括号[]

1、单中括号 []

    ①bash 的内部命令，[和test是等同的。如果我们不用绝对路径指明，通常我们用的都是bash自带的命令。if/test结构中的左中括号是调用test的命令标识，右中括号是关闭条件判断的。这个命令把它的参数作为比较表达式或者作为文件测试，并且根据比较的结果来返回一个退出状态码。if/test结构中并不是必须右中括号，但是新版的Bash中要求必须这样。

    ②Test和[]中可用的比较运算符只有=和!=，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用-eq，-gt这种形式。无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，如果比较"ab"和"bc"：[ ab < bc ]，结果为真，也就是返回状态为0。[ ]中的逻辑与和逻辑或使用-a 和-o 表示。且[]前后都有空格。

    ③字符范围。用作正则表达式的一部分，描述一个匹配的字符范围。作为test用途的中括号内不能使用正则。

    ④在一个array 结构的上下文中，中括号用来引用数组中每个元素的编号。

 

 

2、双中括号[[ ]]

    ①[[是 bash 程序语言的关键字。并不是一个命令，[[ ]] 结构比[ ]结构更加通用。在[[和]]之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。

    ②支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如[[ hello =~ hell? ]]，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。

    ③使用[[ ... ]]条件判断结构，而不是[ ... ]，能够防止脚本中的许多逻辑错误。比如，&&、||、<和> 操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话，会报错。比如可以直接使用if [[ $a != 1 && $a != 2 ]], 如果不适用双括号, 则为if [ $a -ne 1] && [ $a != 2 ]或者if [ $a -ne 1 -a $a != 2 ]。

 

 

1. if ($i<5)    
2. if [ $i -lt 5 ]    
3. if [ $a -ne 1 -a $a != 2 ]    
4. if [ $a -ne 1] && [ $a != 2 ]    
5. if [[ $a != 1 && $a != 2 ]]    
6.      
7. for i in $(seq 0 4);do echo $i;done    
8. for i in seq 0 4;do echo $i;done    
9. for ((i=0;i<5;i++));do echo $i;done    
10. for i in {0..4};do echo $i;done    

三、大括号、花括号 {}

1、常规用法

    ①大括号拓展。(通配(globbing))将对大括号中的文件名做扩展。在大括号中，不允许有空白，除非这个空白被引用或转义。第一种：对大括号中的以逗号分割的文件列表进行拓展。如 touch {a,b}.txt 结果为a.txt b.txt。第二种：对大括号中以点点（..）分割的顺序文件列表起拓展作用，如：touch {a..d}.txt 结果为a.txt b.txt c.txt d.txt

 

    ②代码块，又被称为内部组，这个结构事实上创建了一个匿名函数 。与小括号中的命令不同，大括号内的命令不会新开一个子shell运行，即脚本余下部分仍可使用括号内变量。括号内的命令间用分号隔开，最后一个也必须有分号。{}的第一个命令和左括号之间必须要有一个空格。{}也可以用于多行注释，作为函数包起来只是不调用即可。

 

 

2、几种特殊的替换结构

${var:-string},${var:+string},${var:=string},${var:?string}

      ①${var:-string}和${var:=string}:若变量var为空，则用在命令行中用string来替换${var:-string}，否则变量var不为空时，则用变量var的值来替换${var:-string}；对于${var:=string}的替换规则和${var:-string}是一样的，所不同之处是${var:=string}若var为空时，用string替换${var:=string}的同时，把string赋给变量var： ${var:=string}很常用的一种用法是，判断某个变量是否赋值，没有的话则给它赋上一个默认值。

      ② ${var:+string}的替换规则和上面的相反，即只有当var不是空的时候才替换成string，若var为空时则不替换或者说是替换成变量 var的值，即空值。(因为变量var此时为空，所以这两种说法是等价的) 

      ③${var:?string}替换规则为：若变量var不为空，则用变量var的值来替换${var:?string}；若变量var为空，则把string输出到标准错误中，并从脚本中退出。我们可利用此特性来检查是否设置了变量的值。

      补充扩展：在上面这五种替换结构中string不一定是常值的，可用另外一个变量的值或是一种命令的输出。

3、四种模式匹配替换结构

模式匹配记忆方法：

# 是去掉左边(在键盘上#在$之左边)

% 是去掉右边(在键盘上%在$之右边)

#和%中的单一符号是最小匹配，两个相同符号是最大匹配。

${var%pattern},${var%%pattern},${var#pattern},${var##pattern}

 

 

 

 

 

1. # var=testcase    
2. # echo $var    
3. testcase    
4. # echo ${var%s*e}   
5. testca    
6. # echo $var    
7. testcase   
8. # echo ${var%%s*e}   
9. te  
10. # echo ${var#?e}    
11. stcase  
12. # echo ${var##?e}    
13. stcase  
14. # echo ${var##*e}    
15. 
16. # echo ${var##*s}    
17. e    
18. # echo ${var##test}    
19. case    

 

4、字符串提取和替换

${var:num},${var:num1:num2},${var/pattern/pattern},${var//pattern/pattern}

 

        第二种模式：${var:num1:num2}，num1是位置，num2是长度。表示从$var字符串的第$num1个位置开始提取长度为$num2的子串。不能为负数。

       第三种模式：${var/pattern/pattern}表示将var字符串的第一个匹配的pattern替换为另一个pattern。。        

       第四种模式：${var//pattern/pattern}表示将var字符串中的所有能匹配的pattern替换为另一个pattern。

1. [root@centos ~]# var=/home/centos  
2. [root@centos ~]# echo $var  
3. /home/centos  
4. [root@centos ~]# echo ${var:5}  
5. /centos  
6. [root@centos ~]# echo ${var: -6}  
7. centos  
8. [root@centos ~]# echo ${var:(-6)}  
9. centos  
10. [root@centos ~]# echo ${var:1:4}  
11. home  
12. [root@centos ~]# echo ${var/o/h}  
13. /hhme/centos  
14. [root@centos ~]# echo ${var//o/h}  
15. /hhme/cenths  

 $$

Shell本身的PID（ProcessID，即脚本运行的当前进程ID号）

$!

Shell最后运行的后台Process的PID(后台运行的最后一个进程的进程ID号)

$?

最后运行的命令的结束代码（返回值）即执行上一个指令的返回值 (显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误)

$-

显示shell使用的当前选项，与set命令功能相同

$*

所有参数列表。如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数，此选项参数可超过9个。

$@

所有参数列表。如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。

$@ 跟$*类似，但是可以当作数组用

$#

添加到Shell的参数个数

$0

Shell本身的文件名

$1～$n

添加到Shell的各参数值。$1是第1参数、$2是第2参数…

四、符号$后的括号

（1）${a} 变量a的值, 在不引起歧义的情况下可以省略大括号。

（2）$(cmd) 命令替换，和cmd效果相同，结果为shell命令cmd的输，过某些Shell版本不支持$()形式的命令替换, 如tcsh。

（3）$((expression)) 和exprexpression效果相同, 计算数学表达式exp的数值, 其中exp只要符合C语言的运算规则即可, 甚至三目运算符和逻辑表达式都可以计算。

五、使用

1、多条命令执行

（1）单小括号，(cmd1;cmd2;cmd3) 新开一个子shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后可以没有分号。

（2）单大括号，{ cmd1;cmd2;cmd3;} 在当前shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后必须有分号, 第一条命令和左括号之间必须用空格隔开。

对{}和()而言, 括号中的重定向符只影响该条命令， 而括号外的重定向符影响到括号中的所有命令。



整数比较使用-lt，-gt，ge等比较运算符，详情参考：整数比较

文件测试使用 -d, -f, -x等运算发，详情参考：文件测试

逻辑判断使用    &&(且）、||（或）、！（取反)

字符串比较实用

字符串的比较使用以下三个比较运算符：= 或者（==）、!= 、> 、 <  、  

-z表示后面的值是否为空，为空则返回true，否则返回false。

-n表示判断后面的值是否为空，不为空则返回true，为空则返回false。
